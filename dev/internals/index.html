<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · LazyArrays</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LazyArrays</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Internals</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Internals</a></li></ul><a class="edit-page" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/master/docs/src/internals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Internals</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Internals-1" href="#Internals-1">Internals</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.AbstractStridedLayout" href="#LazyArrays.AbstractStridedLayout"><code>LazyArrays.AbstractStridedLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractStridedLayout</code></pre><p>is an abstract type whose subtypes are returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage laid out at regular offsets in memory, and which can therefore be passed to external C and Fortran functions expecting this memory layout.</p><p>Julia&#39;s internal linear algebra machinery will automatically (and invisibly) dispatch to BLAS and LAPACK routines if the memory layout is BLAS compatible and the element type is a <code>Float32</code>, <code>Float64</code>, <code>ComplexF32</code>, or <code>ComplexF64</code>. In this case, one must implement the strided array interface, which requires overrides of <code>strides(A::MyMatrix)</code> and <code>unknown_convert(::Type{Ptr{T}}, A::MyMatrix)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L32-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.Add-Tuple" href="#LazyArrays.Add-Tuple"><code>LazyArrays.Add</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Add(A1, A2, …, AN)</code></pre><p>A lazy representation of <code>A1 + A2 + … + AN</code>; i.e., a shorthand for <code>applied(+, A1, A2, …, AN)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/linalg/add.jl#L15-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.BroadcastLayout" href="#LazyArrays.BroadcastLayout"><code>LazyArrays.BroadcastLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BroadcastLayout{F}()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> is a <code>BroadcastArray</code>. <code>F</code> is the typeof function that broadcast operation is applied.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/lazybroadcasting.jl#L94-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.ColumnMajor" href="#LazyArrays.ColumnMajor"><code>LazyArrays.ColumnMajor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ColumnMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a column major array, so that <code>stride(A,1) == 1</code> and <code>stride(A,i) ≥ size(A,i-1) * stride(A,i-1)</code> for <code>2 ≤ i ≤ ndims(A)</code>.</p><p>Arrays with <code>ColumnMajor</code> memory layout must conform to the <code>DenseArray</code> interface.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L60-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.DecreasingStrides" href="#LazyArrays.DecreasingStrides"><code>LazyArrays.DecreasingStrides</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DecreasingStrides()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a strided array with decreasing strides, so that <code>stride(A,ndims(A)) ≥ 1</code> and stride(A,i) ≥ size(A,i+1) * stride(A,i+1)<code>for</code>1 ≤ i ≤ ndims(A)-1`.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L102-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.DenseColumnMajor" href="#LazyArrays.DenseColumnMajor"><code>LazyArrays.DenseColumnMajor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DenseColumnMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory equivalent to an <code>Array</code>, so that <code>stride(A,1) == 1</code> and <code>stride(A,i) ≡ size(A,i-1) * stride(A,i-1)</code> for <code>2 ≤ i ≤ ndims(A)</code>. In particular, if <code>A</code> is a matrix then <code>strides(A) ==</code>(1, size(A,1))`.</p><p>Arrays with <code>DenseColumnMajor</code> memory layout must conform to the <code>DenseArray</code> interface.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L48-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.DenseRowMajor" href="#LazyArrays.DenseRowMajor"><code>LazyArrays.DenseRowMajor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DenseRowMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a row major array with dense entries, so that <code>stride(A,ndims(A)) == 1</code> and <code>stride(A,i) ≡ size(A,i+1) * stride(A,i+1)</code> for <code>1 ≤ i ≤ ndims(A)-1</code>. In particular, if <code>A</code> is a matrix then <code>strides(A) ==</code>(size(A,2), 1)`.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L80-L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.HermitianLayout" href="#LazyArrays.HermitianLayout"><code>LazyArrays.HermitianLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HermitianLayout(layout, uplo)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory as a hermitianized version of <code>layout</code>, where the entries used are dictated by the <code>uplo</code>, which can be <code>&#39;U&#39;</code> or <code>L&#39;</code>.</p><p>A matrix that has memory layout <code>HermitianLayout(layout, uplo)</code> must overrided <code>hermitiandata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] == B[k,j]</code> for <code>j ≥ k</code> if <code>uplo == &#39;U&#39;</code> (<code>j ≤ k</code> if <code>uplo == &#39;L&#39;</code>) and <code>A[k,j] == conj(B[j,k])</code> for <code>j &lt; k</code> if <code>uplo == &#39;U&#39;</code> (<code>j &gt; k</code> if <code>uplo == &#39;L&#39;</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L274-L286">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.IncreasingStrides" href="#LazyArrays.IncreasingStrides"><code>LazyArrays.IncreasingStrides</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IncreasingStrides()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a strided array with  increasing strides, so that <code>stride(A,1) ≥ 1</code> and <code>stride(A,i) ≥ size(A,i-1) * stride(A,i-1)</code> for <code>2 ≤ i ≤ ndims(A)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L71-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.LowerTriangularLayout" href="#LazyArrays.LowerTriangularLayout"><code>LazyArrays.LowerTriangularLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">LowerTriangularLayout(layout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>LowerTriangular(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == layout</code>.</p><p>A matrix that has memory layout <code>LowerTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &gt; k</code> and <code>A[k,j] ≡ B[k,j]</code> for <code>j ≤ k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>UpperTriangularLayout</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L323-L336">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.MemoryLayout-Tuple{Type}" href="#LazyArrays.MemoryLayout-Tuple{Type}"><code>LazyArrays.MemoryLayout</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">MemoryLayout(A)</code></pre><p>specifies the layout in memory for an array <code>A</code>. When you define a new <code>AbstractArray</code> type, you can choose to override <code>MemoryLayout</code> to indicate how an array is stored in memory. For example, if your matrix is column major with <code>stride(A,2) == size(A,1)</code>, then override as follows:</p><pre><code class="language-none">MemoryLayout(::MyMatrix) = DenseColumnMajor()</code></pre><p>The default is <code>UnknownLayout()</code> to indicate that the layout in memory is unknown.</p><p>Julia&#39;s internal linear algebra machinery will automatically (and invisibly) dispatch to BLAS and LAPACK routines if the memory layout is compatible.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L126-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.RowMajor" href="#LazyArrays.RowMajor"><code>LazyArrays.RowMajor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RowMajor()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage in memory as a row major array, so that <code>stride(A,ndims(A)) == 1</code> and stride(A,i) ≥ size(A,i+1) * stride(A,i+1)<code>for</code>1 ≤ i ≤ ndims(A)-1`.</p><p>If <code>A</code> is a matrix  with <code>RowMajor</code> memory layout, then <code>transpose(A)</code> should return a matrix whose layout is <code>ColumnMajor</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L90-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.ScalarLayout" href="#LazyArrays.ScalarLayout"><code>LazyArrays.ScalarLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ScalarLayout()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if A is a scalar, which does not live in memory</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L119-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.StridedLayout" href="#LazyArrays.StridedLayout"><code>LazyArrays.StridedLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StridedLayout()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if an array <code>A</code> has storage laid out at regular offsets in memory. <code>Array</code>s with <code>StridedLayout</code> must conform to the <code>DenseArray</code> interface.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L111-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.SymmetricLayout" href="#LazyArrays.SymmetricLayout"><code>LazyArrays.SymmetricLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SymmetricLayout{layout}()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory as a symmetrized version of <code>layout</code>, where the entries used are dictated by the <code>uplo</code>, which can be <code>&#39;U&#39;</code> or <code>L&#39;</code>.</p><p>A matrix that has memory layout <code>SymmetricLayout(layout, uplo)</code> must overrided <code>symmetricdata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] == B[k,j]</code> for <code>j ≥ k</code> if <code>uplo == &#39;U&#39;</code> (<code>j ≤ k</code> if <code>uplo == &#39;L&#39;</code>) and <code>A[k,j] == B[j,k]</code> for <code>j &lt; k</code> if <code>uplo == &#39;U&#39;</code> (<code>j &gt; k</code> if <code>uplo == &#39;L&#39;</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L259-L271">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.UnitLowerTriangularLayout" href="#LazyArrays.UnitLowerTriangularLayout"><code>LazyArrays.UnitLowerTriangularLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">UnitLowerTriangularLayout(ML::MemoryLayout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>UnitLowerTriangular(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == layout</code>.</p><p>A matrix that has memory layout <code>UnitLowerTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &gt; k</code>, <code>A[k,j] ≡ one(eltype(A))</code> for <code>j == k</code>, <code>A[k,j] ≡ B[k,j]</code> for <code>j &lt; k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>UnitUpperTriangularLayout</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L339-L353">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.UnitUpperTriangularLayout" href="#LazyArrays.UnitUpperTriangularLayout"><code>LazyArrays.UnitUpperTriangularLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">UnitUpperTriangularLayout(ML::MemoryLayout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>UpperTriangularLayout(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == ML</code>.</p><p>A matrix that has memory layout <code>UnitUpperTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ B[k,j]</code> for <code>j &gt; k</code>, <code>A[k,j] ≡ one(eltype(A))</code> for <code>j == k</code>, <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &lt; k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>UnitLowerTriangularLayout</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L372-L386">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.UnknownLayout" href="#LazyArrays.UnknownLayout"><code>LazyArrays.UnknownLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">UnknownLayout()</code></pre><p>is returned by <code>MemoryLayout(A)</code> if it is unknown how the entries of an array <code>A</code> are stored in memory.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L24-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.UpperTriangularLayout" href="#LazyArrays.UpperTriangularLayout"><code>LazyArrays.UpperTriangularLayout</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">UpperTriangularLayout(ML::MemoryLayout)</code></pre><p>is returned by <code>MemoryLayout(A)</code> if a matrix <code>A</code> has storage in memory equivalent to a <code>UpperTriangularLayout(B)</code> where <code>B</code> satisfies <code>MemoryLayout(B) == ML</code>.</p><p>A matrix that has memory layout <code>UpperTriangularLayout(layout)</code> must overrided <code>triangulardata(A)</code> to return a matrix <code>B</code> such that <code>MemoryLayout(B) == layout</code> and <code>A[k,j] ≡ B[k,j]</code> for <code>j ≥ k</code> and <code>A[k,j] ≡ zero(eltype(A))</code> for <code>j &lt; k</code>.</p><p>Moreover, <code>transpose(A)</code> and <code>adjoint(A)</code> must return a matrix that has memory layout <code>LowerTriangularLayout</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/memorylayout.jl#L356-L369">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.colsupport-Tuple{Any,Any}" href="#LazyArrays.colsupport-Tuple{Any,Any}"><code>LazyArrays.colsupport</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>&quot;     colsupport(A, j)</p><p>gives an iterator containing the possible non-zero entries in the j-th column of A.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/linalg/mul.jl#L131-L136">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.lmaterialize-Tuple{Applied{Style,typeof(*),Factors} where Factors&lt;:Tuple where Style}" href="#LazyArrays.lmaterialize-Tuple{Applied{Style,typeof(*),Factors} where Factors&lt;:Tuple where Style}"><code>LazyArrays.lmaterialize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>lmaterialize(M::Mul)</p><p>materializes arrays iteratively, left-to-right.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/linalg/mul.jl#L90-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyArrays.rowsupport-Tuple{Any,Any}" href="#LazyArrays.rowsupport-Tuple{Any,Any}"><code>LazyArrays.rowsupport</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>&quot;     rowsupport(A, k)</p><p>gives an iterator containing the possible non-zero entries in the k-th row of A.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaArrays/LazyArrays.jl/blob/000242810077cccd3a7fe692e736804af176a84b/src/linalg/mul.jl#L122-L127">source</a></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></html>
